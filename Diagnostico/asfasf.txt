#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <TDACola.h>

#define MAX 50 
typedef struct {
    int DiaReserva,EspacioReservado,MesesMora;
    char CodigoVecino[5];   // espacio para el /0
}TReserva;
typedef TReserva TElementoC;
typedef struct {
    TElementoC datos[MAX];
    int pri, ult;
 } TCola;
//Las funciones definidas irian en un .c y declaradas en un .h
typedef struct nodito {
    char CodigoVecino[5];  
    int DiaReserva;
    struct nodito* sig;
}nodito;
typedef nodito* TsubL;
typedef struct nodoSL{ 
    int espacio,maxRes;
    char descripcion[21]; 
    struct nodoSL* sig;
    TsubL sub;
}nodoSL;
typedef nodoSL* TlistaSL;

void QuitaQuincena(int Mat[][31],TlistaSL L,int *CantResLib,int *LugMR);
void EsParMasRes(int Mat[][31],int M,int N,int i,int j,int reservas,int ResMax,int *espacio);
void AgregaRes(int M[][31],TCola *C,TReserva R,TlistaSL L,int x,int *Adeudados);
int main() {
    int MRes[20][31];
    TlistaSL L = NULL;
    int x,adeudados = 0,espacio,CantResLib,LugMasRes;
    TCola C;
    FILE* arch;
    TReserva R;
    InicializaLista(&L);//inicializo lista con espacios y descripciones (todo ahi)
    IniciaC(&C);//inicializo cola
    iniciaM(MRes,20,31);//inicializo matriz todo en 0 
    scanf("%d",&x);//meses adeudados maximos aceptables

    arch = fopen("Reservas.txt","r"); 
fscanf(arch,"%d %d %s %d",&R.DiaReserva,&R.EspacioReservado,R.CodigoVecino,&R.MesesMora);
    while(!feof(arch)) {
        
        AgregaRes(MRes,&C,R,L,x,&adeudados);
fscanf(arch,"%d %d %s %d",&R.DiaReserva,&R.EspacioReservado,R.CodigoVecino,&R.MesesMora);
    }
    fclose(arch);
    printf("Las reservas no hechas por haber sido solicitadas por vecinos con deudas es de: %d\n",adeudados);
    EsParMasRes(MRes,31,20,0,0,0,-1,&espacio);
    printf("El espacio par con mas cantidad de reservas para este mes es: %d\n",espacio);
    QuitaQuincena(MRes,L,&CantResLib,&LugMasRes);
    printf("La cantidad de reservas liberadas fue: %d, y el lugar comun que ha liberado la mayor cantidad de reservas fue: %d\n",CantResLib,LugMasRes);
 
  

}

void AgregaRes(int M[][31],TCola *C,TReserva R,TlistaSL L,int x,int *Adeudados){
    TsubL ant,act,nuevo;
    if(R.MesesMora<=x) {
            while(L != NULL && L->espacio != R.EspacioReservado
                L = L->sig;
            if( L != NULL && L->maxRes - (M[R.EspacioReservado][R.DiaReserva - 1] + 1) >= 0) {
                M[R.EspacioReservado][R.DiaReserva - 1]++;
                nuevo = (TsubL) malloc(sizeof(nodito));
                nuevo->DiaReserva = R.DiaReserva;
                strcpy(nuevo->CodigoVecino,R.CodigoVecino);
                if(L->sub == NULL || R.DiaReserva < L->sub->DiaReserva) {  //ver siguiente comentario
                    nuevo->sig = L->sub;
                    L->sub = nuevo;
                }else{
                    ant = L->sub;  //ver siguiente comentario
                    act = L->sub->sig;
                    while(act != NULL && R.DiaReserva > act->DiaReserva){
                        ant = act;
                        act = act->sig;
                    }
                    ant->sig = nuevo;
                    nuevo->sig = act;
                } // Inserta mal cuando el dia de la reserva nueva es igual al dia del primer nodo
            }else
                poneC(C,R);
    }else
        *Adeudados ++;
}
void EsParMasRes(int Mat[][31],int M,int N,int i,int j,int reservas,int ResMax,int *espacio) {
    if(i<N){
        if(j<M){
            reservas += Mat[i][j];
            EsParMasRes(Mat,M,N,i,j+1,reservas,ResMax,espacio);
        }else{
            if(ResMax < reservas){
                ResMax = reservas;
                *espacio = i;
            }
            EsParMasRes(Mat,M,N,i+2,0,0,ResMax,espacio);
        }
    }
}
void QuitaQuincena(int Mat[][31],TlistaSL L,int *CantResLib,int *LugMR) {
    TsubL elim;
    int resLug,resMax = -1;
    *CantResLib = 0;
    *LugMR = 0;
    while(L != NULL) {
        resLug = 0;
        while(L->sub != NULL && L->sub->DiaReserva < 16){//elimino siempre la cabeza (en caso que se elimine alguno) debido al orden de la sublista
            *CantResLib += 1;  //++
            resLug++;
            elim = L->sub;
            L->sub = L->sub->sig;
            Mat[L->espacio][elim->DiaReserva-1] = 0; 
            free(elim);
        }
        if(resMax < resLug){
            *LugMR = L->espacio;
            resMax = resLug;
        }
       
        L = L->sig;
    }
}
